From d06545351d61a52120d5bc40d1b20f5272b74857 Mon Sep 17 00:00:00 2001
From: Peridot <peridot491@protonmail.com>
Date: Wed, 11 May 2022 17:42:41 +0200
Subject: [PATCH] Async chunk generation


diff --git a/src/main/java/net/minecraft/server/ChunkProviderGenerate.java b/src/main/java/net/minecraft/server/ChunkProviderGenerate.java
index 1c08afa52..23c69f185 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderGenerate.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderGenerate.java
@@ -1,18 +1,29 @@
 package net.minecraft.server;
 
+import java.lang.reflect.Field;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Random;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.concurrent.atomic.AtomicLong;
+import net.titanium.executor.AsynchronousExecutor;
+import org.bukkit.Bukkit;
 
 public class ChunkProviderGenerate implements IChunkProvider {
 
-    private Random h;
+    private final long seed;
+    // Titanium start
+    /*private Random h;
     private NoiseGeneratorOctaves i;
     private NoiseGeneratorOctaves j;
     private NoiseGeneratorOctaves k;
     private NoiseGenerator3 l;
     public NoiseGeneratorOctaves a;
     public NoiseGeneratorOctaves b;
-    public NoiseGeneratorOctaves c;
+    public NoiseGeneratorOctaves c;*/
+    // Titanium end
     private World m;
     private final boolean n;
     private WorldType o;
@@ -28,11 +39,51 @@ public class ChunkProviderGenerate implements IChunkProvider {
     private WorldGenLargeFeature y;
     private WorldGenBase z;
     private WorldGenMonument A;
-    private BiomeBase[] B;
+
+    // Titanium start
+    /*private BiomeBase[] B;
     double[] d;
     double[] e;
     double[] f;
-    double[] g;
+    double[] g;*/
+
+    private final ThreadLocal<ChunkGenData> chunkGenData = ThreadLocal.withInitial(() -> new ChunkGenData(ChunkProviderGenerate.this.seed));
+
+    public ChunkGenData getChunkData() {
+        return chunkGenData.get();
+    }
+
+    private class ChunkGenData {
+
+        private final long seed;
+        private final Random h;
+        private final NoiseGeneratorOctaves i;
+        private final NoiseGeneratorOctaves j;
+        private final NoiseGeneratorOctaves k;
+        private final NoiseGenerator3 l;
+        public NoiseGeneratorOctaves a;
+        public NoiseGeneratorOctaves b;
+        public NoiseGeneratorOctaves c;
+        private BiomeBase[] B;
+        private double[] d;
+        private double[] e;
+        private double[] f;
+        private double[] g;
+
+        private ChunkGenData(long seed) {
+            this.seed = seed;
+            this.h = new Random(this.seed);
+            this.i = new NoiseGeneratorOctaves(this.h, 16);
+            this.j = new NoiseGeneratorOctaves(this.h, 16);
+            this.k = new NoiseGeneratorOctaves(this.h, 8);
+            this.l = new NoiseGenerator3(this.h, 4);
+            this.a = new NoiseGeneratorOctaves(this.h, 10);
+            this.b = new NoiseGeneratorOctaves(this.h, 16);
+            this.c = new NoiseGeneratorOctaves(this.h, 8);
+        }
+
+    }
+    // Titanium end
 
     public ChunkProviderGenerate(World world, long i, boolean flag, String s) {
         this.s = Blocks.WATER;
@@ -47,14 +98,17 @@ public class ChunkProviderGenerate implements IChunkProvider {
         this.m = world;
         this.n = flag;
         this.o = world.getWorldData().getType();
-        this.h = new Random(i);
+        this.seed = i;
+        // Titanium start
+        /*this.h = new Random(this.seed);
         this.i = new NoiseGeneratorOctaves(this.h, 16);
         this.j = new NoiseGeneratorOctaves(this.h, 16);
         this.k = new NoiseGeneratorOctaves(this.h, 8);
         this.l = new NoiseGenerator3(this.h, 4);
         this.a = new NoiseGeneratorOctaves(this.h, 10);
         this.b = new NoiseGeneratorOctaves(this.h, 16);
-        this.c = new NoiseGeneratorOctaves(this.h, 8);
+        this.c = new NoiseGeneratorOctaves(this.h, 8);*/
+        // Titanium end
         this.p = new double[825];
         this.q = new float[25];
 
@@ -75,7 +129,10 @@ public class ChunkProviderGenerate implements IChunkProvider {
     }
 
     public void a(int i, int j, ChunkSnapshot chunksnapshot) {
-        this.B = this.m.getWorldChunkManager().getBiomes(this.B, i * 4 - 2, j * 4 - 2, 10, 10);
+        synchronized (this) {
+            this.getChunkData().B = this.m.getWorldChunkManager().getBiomes(this.getChunkData().B, i * 4 - 2, j * 4 - 2, 10, 10);
+        }
+
         this.a(i * 4, 0, j * 4);
 
         for (int k = 0; k < 4; ++k) {
@@ -131,31 +188,35 @@ public class ChunkProviderGenerate implements IChunkProvider {
                 }
             }
         }
-
     }
 
     public void a(int i, int j, ChunkSnapshot chunksnapshot, BiomeBase[] abiomebase) {
         double d0 = 0.03125D;
 
-        this.t = this.l.a(this.t, (double) (i * 16), (double) (j * 16), 16, 16, d0 * 2.0D, d0 * 2.0D, 1.0D);
+        this.t = this.getChunkData().l.a(this.t, (double) (i * 16), (double) (j * 16), 16, 16, d0 * 2.0D, d0 * 2.0D, 1.0D);
 
         for (int k = 0; k < 16; ++k) {
             for (int l = 0; l < 16; ++l) {
                 BiomeBase biomebase = abiomebase[l + k * 16];
 
-                biomebase.a(this.m, this.h, chunksnapshot, i * 16 + k, j * 16 + l, this.t[l + k * 16]);
+                biomebase.a(this.m, this.getChunkData().h, chunksnapshot, i * 16 + k, j * 16 + l, this.t[l + k * 16]);
             }
         }
 
     }
 
     public Chunk getOrCreateChunk(int i, int j) {
-        this.h.setSeed((long) i * 341873128712L + (long) j * 132897987541L);
+        ChunkGenData chunkGenData = this.getChunkData();
+
+        long seed = (long) i * 341873128712L + (long) j * 132897987541L;
+        chunkGenData.h.setSeed(seed);
         ChunkSnapshot chunksnapshot = new ChunkSnapshot();
 
         this.a(i, j, chunksnapshot);
-        this.B = this.m.getWorldChunkManager().getBiomeBlock(this.B, i * 16, j * 16, 16, 16);
-        this.a(i, j, chunksnapshot, this.B);
+        this.getChunkData().B = this.m.getWorldChunkManager().getBiomeBlock(chunkGenData.B, i * 16, j * 16, 16, 16);
+        this.a(i, j, chunksnapshot, chunkGenData.B);
+
+        // Titanium - we can generate caves and canyons asynchronously
         if (this.r.r && this.m.paperConfigTitanium.generatorSettings.caves) { // PaperSpigot
             this.u.a(this, this.m, i, j, chunksnapshot);
         }
@@ -164,31 +225,13 @@ public class ChunkProviderGenerate implements IChunkProvider {
             this.z.a(this, this.m, i, j, chunksnapshot);
         }
 
-        if (this.r.w && this.n && this.m.paperConfigTitanium.generatorSettings.mineshaft) { // PaperSpigot
-            this.x.a(this, this.m, i, j, chunksnapshot);
-        }
-
-        if (this.r.v && this.n && this.m.paperConfigTitanium.generatorSettings.village) { // PaperSpigot
-            this.w.a(this, this.m, i, j, chunksnapshot);
-        }
-
-        if (this.r.u && this.n && this.m.paperConfigTitanium.generatorSettings.stronghold) { // PaperSpigot
-            this.v.a(this, this.m, i, j, chunksnapshot);
-        }
-
-        if (this.r.x && this.n && this.m.paperConfigTitanium.generatorSettings.temple) { // PaperSpigot
-            this.y.a(this, this.m, i, j, chunksnapshot);
-        }
-
-        if (this.r.y && this.n && this.m.paperConfigTitanium.generatorSettings.monument) { // PaperSpigot
-            this.A.a(this, this.m, i, j, chunksnapshot);
-        }
+        this.createStructures(i, j, chunksnapshot);
 
         Chunk chunk = new Chunk(this.m, chunksnapshot, i, j);
         byte[] abyte = chunk.getBiomeIndex();
 
         for (int k = 0; k < abyte.length; ++k) {
-            abyte[k] = (byte) this.B[k].id;
+            abyte[k] = (byte) this.getChunkData().B[k].id;
         }
 
         chunk.initLighting();
@@ -196,13 +239,17 @@ public class ChunkProviderGenerate implements IChunkProvider {
     }
 
     private void a(int i, int j, int k) {
-        this.g = this.b.a(this.g, i, k, 5, 5, (double) this.r.e, (double) this.r.f, (double) this.r.g);
+        ChunkGenData chunkGenData = this.getChunkData();
+
+        chunkGenData.g = chunkGenData.b.a(chunkGenData.g, i, k, 5, 5, (double) this.r.e, (double) this.r.f, (double) this.r.g);
+
         float f = this.r.a;
         float f1 = this.r.b;
 
-        this.d = this.k.a(this.d, i, j, k, 5, 33, 5, (double) (f / this.r.h), (double) (f1 / this.r.i), (double) (f / this.r.j));
-        this.e = this.i.a(this.e, i, j, k, 5, 33, 5, (double) f, (double) f1, (double) f);
-        this.f = this.j.a(this.f, i, j, k, 5, 33, 5, (double) f, (double) f1, (double) f);
+        chunkGenData.d = chunkGenData.k.a(chunkGenData.d, i, j, k, 5, 33, 5, (double) (f / this.r.h), (double) (f1 / this.r.i), (double) (f / this.r.j));
+        chunkGenData.e = chunkGenData.i.a(chunkGenData.e, i, j, k, 5, 33, 5, (double) f, (double) f1, (double) f);
+        chunkGenData.f = chunkGenData.j.a(chunkGenData.f, i, j, k, 5, 33, 5, (double) f, (double) f1, (double) f);
+
         boolean flag = false;
         boolean flag1 = false;
         int l = 0;
@@ -214,11 +261,11 @@ public class ChunkProviderGenerate implements IChunkProvider {
                 float f3 = 0.0F;
                 float f4 = 0.0F;
                 byte b0 = 2;
-                BiomeBase biomebase = this.B[j1 + 2 + (k1 + 2) * 10];
+                BiomeBase biomebase = chunkGenData.B[j1 + 2 + (k1 + 2) * 10];
 
                 for (int l1 = -b0; l1 <= b0; ++l1) {
                     for (int i2 = -b0; i2 <= b0; ++i2) {
-                        BiomeBase biomebase1 = this.B[j1 + l1 + 2 + (k1 + i2 + 2) * 10];
+                        BiomeBase biomebase1 = chunkGenData.B[j1 + l1 + 2 + (k1 + i2 + 2) * 10];
                         float f5 = this.r.n + biomebase1.an * this.r.m;
                         float f6 = this.r.p + biomebase1.ao * this.r.o;
 
@@ -243,7 +290,7 @@ public class ChunkProviderGenerate implements IChunkProvider {
                 f3 /= f4;
                 f2 = f2 * 0.9F + 0.1F;
                 f3 = (f3 * 4.0F - 1.0F) / 8.0F;
-                double d0 = this.g[i1] / 8000.0D;
+                double d0 = chunkGenData.g[i1] / 8000.0D;
 
                 if (d0 < 0.0D) {
                     d0 = -d0 * 0.3D;
@@ -281,9 +328,9 @@ public class ChunkProviderGenerate implements IChunkProvider {
                         d4 *= 4.0D;
                     }
 
-                    double d5 = this.e[l] / (double) this.r.d;
-                    double d6 = this.f[l] / (double) this.r.c;
-                    double d7 = (this.d[l] / 10.0D + 1.0D) / 2.0D;
+                    double d5 = chunkGenData.e[l] / (double) this.r.d;
+                    double d6 = chunkGenData.f[l] / (double) this.r.c;
+                    double d7 = (chunkGenData.d[l] / 10.0D + 1.0D) / 2.0D;
                     double d8 = MathHelper.b(d5, d6, d7) - d4;
 
                     if (j2 > 29) {
@@ -297,7 +344,6 @@ public class ChunkProviderGenerate implements IChunkProvider {
                 }
             }
         }
-
     }
 
     public boolean isChunkLoaded(int i, int j) {
@@ -305,72 +351,73 @@ public class ChunkProviderGenerate implements IChunkProvider {
     }
 
     public void getChunkAt(IChunkProvider ichunkprovider, int i, int j) {
+        ChunkGenData chunkGenData = this.getChunkData();
         BlockFalling.instaFall = true;
         int k = i * 16;
         int l = j * 16;
         BlockPosition blockposition = new BlockPosition(k, 0, l);
         BiomeBase biomebase = this.m.getBiome(blockposition.a(16, 0, 16));
 
-        this.h.setSeed(this.m.getSeed());
-        long i1 = this.h.nextLong() / 2L * 2L + 1L;
-        long j1 = this.h.nextLong() / 2L * 2L + 1L;
+        chunkGenData.h.setSeed(this.m.getSeed());
+        long i1 = chunkGenData.h.nextLong() / 2L * 2L + 1L;
+        long j1 = chunkGenData.h.nextLong() / 2L * 2L + 1L;
 
-        this.h.setSeed((long) i * i1 + (long) j * j1 ^ this.m.getSeed());
+        chunkGenData.h.setSeed((long) i * i1 + (long) j * j1 ^ this.m.getSeed());
         boolean flag = false;
         ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
 
         if (this.r.w && this.n && this.m.paperConfigTitanium.generatorSettings.mineshaft) { // PaperSpigot
-            this.x.a(this.m, this.h, chunkcoordintpair);
+            this.x.a(this.m, chunkGenData.h, chunkcoordintpair);
         }
 
         if (this.r.v && this.n && this.m.paperConfigTitanium.generatorSettings.mineshaft) { // PaperSpigot
-            flag = this.w.a(this.m, this.h, chunkcoordintpair);
+            flag = this.w.a(this.m, chunkGenData.h, chunkcoordintpair);
         }
 
         if (this.r.u && this.n && this.m.paperConfigTitanium.generatorSettings.stronghold) { // PaperSpigot
-            this.v.a(this.m, this.h, chunkcoordintpair);
+            this.v.a(this.m, chunkGenData.h, chunkcoordintpair);
         }
 
         if (this.r.x && this.n && this.m.paperConfigTitanium.generatorSettings.temple) { // PaperSpigot
-            this.y.a(this.m, this.h, chunkcoordintpair);
+            this.y.a(this.m, chunkGenData.h, chunkcoordintpair);
         }
 
         if (this.r.y && this.n && this.m.paperConfigTitanium.generatorSettings.monument) { // PaperSpigot
-            this.A.a(this.m, this.h, chunkcoordintpair);
+            this.A.a(this.m, chunkGenData.h, chunkcoordintpair);
         }
 
         int k1;
         int l1;
         int i2;
 
-        if (biomebase != BiomeBase.DESERT && biomebase != BiomeBase.DESERT_HILLS && this.r.A && !flag && this.h.nextInt(this.r.B) == 0) {
-            k1 = this.h.nextInt(16) + 8;
-            l1 = this.h.nextInt(256);
-            i2 = this.h.nextInt(16) + 8;
-            (new WorldGenLakes(Blocks.WATER)).generate(this.m, this.h, blockposition.a(k1, l1, i2));
+        if (biomebase != BiomeBase.DESERT && biomebase != BiomeBase.DESERT_HILLS && this.r.A && !flag && chunkGenData.h.nextInt(this.r.B) == 0) {
+            k1 = this.getChunkData().h.nextInt(16) + 8;
+            l1 = this.getChunkData().h.nextInt(256);
+            i2 = this.getChunkData().h.nextInt(16) + 8;
+            (new WorldGenLakes(Blocks.WATER)).generate(this.m, chunkGenData.h, blockposition.a(k1, l1, i2));
         }
 
-        if (!flag && this.h.nextInt(this.r.D / 10) == 0 && this.r.C) {
-            k1 = this.h.nextInt(16) + 8;
-            l1 = this.h.nextInt(this.h.nextInt(248) + 8);
-            i2 = this.h.nextInt(16) + 8;
-            if (l1 < this.m.F() || this.h.nextInt(this.r.D / 8) == 0) {
-                (new WorldGenLakes(Blocks.LAVA)).generate(this.m, this.h, blockposition.a(k1, l1, i2));
+        if (!flag && this.getChunkData().h.nextInt(this.r.D / 10) == 0 && this.r.C) {
+            k1 = this.getChunkData().h.nextInt(16) + 8;
+            l1 = this.getChunkData().h.nextInt(chunkGenData.h.nextInt(248) + 8);
+            i2 = this.getChunkData().h.nextInt(16) + 8;
+            if (l1 < this.m.F() || chunkGenData.h.nextInt(this.r.D / 8) == 0) {
+                (new WorldGenLakes(Blocks.LAVA)).generate(this.m, chunkGenData.h, blockposition.a(k1, l1, i2));
             }
         }
 
         if (this.r.s && this.m.paperConfigTitanium.generatorSettings.dungeon) { // PaperSpigot
             for (k1 = 0; k1 < this.r.t; ++k1) {
-                l1 = this.h.nextInt(16) + 8;
-                i2 = this.h.nextInt(256);
-                int j2 = this.h.nextInt(16) + 8;
+                l1 = chunkGenData.h.nextInt(16) + 8;
+                i2 = chunkGenData.h.nextInt(256);
+                int j2 = chunkGenData.h.nextInt(16) + 8;
 
-                (new WorldGenDungeons()).generate(this.m, this.h, blockposition.a(l1, i2, j2));
+                (new WorldGenDungeons()).generate(this.m, chunkGenData.h, blockposition.a(l1, i2, j2));
             }
         }
 
-        biomebase.a(this.m, this.h, new BlockPosition(k, 0, l));
-        SpawnerCreature.a(this.m, biomebase, k + 8, l + 8, 16, 16, this.h);
+        biomebase.a(this.m, this.getChunkData().h, new BlockPosition(k, 0, l));
+        SpawnerCreature.a(this.m, biomebase, k + 8, l + 8, 16, 16, chunkGenData.h);
         blockposition = blockposition.a(8, 0, 8);
 
         for (k1 = 0; k1 < 16; ++k1) {
@@ -395,7 +442,7 @@ public class ChunkProviderGenerate implements IChunkProvider {
         boolean flag = false;
 
         if (this.r.y && this.n && chunk.w() < 3600L) {
-            flag |= this.A.a(this.m, this.h, new ChunkCoordIntPair(i, j));
+            flag |= this.A.a(this.m, this.getChunkData().h, new ChunkCoordIntPair(i, j));
         }
 
         return flag;
@@ -405,7 +452,8 @@ public class ChunkProviderGenerate implements IChunkProvider {
         return true;
     }
 
-    public void c() {}
+    public void c() {
+    }
 
     public boolean unloadChunks() {
         return false;
@@ -443,30 +491,36 @@ public class ChunkProviderGenerate implements IChunkProvider {
         return 0;
     }
 
-    public void recreateStructures(Chunk chunk, int i, int j) {
-        if (this.r.w && this.n && this.m.paperConfigTitanium.generatorSettings.mineshaft) { // PaperSpigot
-            this.x.a(this, this.m, i, j, (ChunkSnapshot) null);
-        }
+    public void createStructures(int i, int j, ChunkSnapshot chunksnapshot) {
+        synchronized (this) { // Titanium synchronize structure generation
+            if (this.r.w && this.n && this.m.paperConfigTitanium.generatorSettings.mineshaft) { // PaperSpigot
+                this.x.a(this, this.m, i, j, chunksnapshot);
+            }
 
-        if (this.r.v && this.n && this.m.paperConfigTitanium.generatorSettings.village) { // PaperSpigot
-            this.w.a(this, this.m, i, j, (ChunkSnapshot) null);
-        }
+            if (this.r.v && this.n && this.m.paperConfigTitanium.generatorSettings.village) { // PaperSpigot
+                this.w.a(this, this.m, i, j, chunksnapshot);
+            }
 
-        if (this.r.u && this.n && this.m.paperConfigTitanium.generatorSettings.stronghold) { // PaperSpigot
-            this.v.a(this, this.m, i, j, (ChunkSnapshot) null);
-        }
+            if (this.r.u && this.n && this.m.paperConfigTitanium.generatorSettings.stronghold) { // PaperSpigot
+                this.v.a(this, this.m, i, j, chunksnapshot);
+            }
 
-        if (this.r.x && this.n && this.m.paperConfigTitanium.generatorSettings.temple) { // PaperSpigot
-            this.y.a(this, this.m, i, j, (ChunkSnapshot) null);
-        }
+            if (this.r.x && this.n && this.m.paperConfigTitanium.generatorSettings.temple) { // PaperSpigot
+                this.y.a(this, this.m, i, j, chunksnapshot);
+            }
 
-        if (this.r.y && this.n && this.m.paperConfigTitanium.generatorSettings.monument) { // PaperSpigot
-            this.A.a(this, this.m, i, j, (ChunkSnapshot) null);
+            if (this.r.y && this.n && this.m.paperConfigTitanium.generatorSettings.monument) { // PaperSpigot
+                this.A.a(this, this.m, i, j, chunksnapshot);
+            }
         }
+    }
 
+    public void recreateStructures(Chunk chunk, int i, int j) {
+        this.createStructures(i, j, null);
     }
 
     public Chunk getChunkAt(BlockPosition blockposition) {
         return this.getOrCreateChunk(blockposition.getX() >> 4, blockposition.getZ() >> 4);
     }
+
 }
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index b1310c1f9..d3ef96177 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -5,6 +5,9 @@ import java.io.IOException;
 import java.util.Iterator;
 import java.util.List;
 
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import net.titanium.chunk.gen.ChunkGenExecutor;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -20,8 +23,6 @@ import org.github.paperspigot.event.ServerExceptionEvent;
 import org.github.paperspigot.exception.ServerInternalException;
 // CraftBukkit end
 // SportPaper start
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.longs.LongArraySet;
 import it.unimi.dsi.fastutil.longs.LongSet;
@@ -37,7 +38,11 @@ public class ChunkProviderServer implements IChunkProvider {
     public IChunkLoader chunkLoader;
     public boolean forceChunkLoad = false; // CraftBukkit - true -> false
     // Paper start
+
+    // Titanium start
+    /*
     protected Chunk lastChunkByPos = null;
+
     public Long2ObjectMap<Chunk> chunks = new Long2ObjectOpenHashMap<Chunk>(8192, 0.5f) {
         @Override
         public Chunk get(long key) {
@@ -54,7 +59,46 @@ public class ChunkProviderServer implements IChunkProvider {
             }
             return super.remove(key);
         }
-    }; // CraftBukkit
+    }; // CraftBukkit */
+
+    public Map<Long, Chunk> chunks = new ChunkMap(8192, 0.5f);
+
+    private class ChunkMap extends ConcurrentHashMap<Long, Chunk> {
+
+        protected ThreadLocal<Chunk> lastChunkByPosThread = new ThreadLocal<>();
+
+        public ChunkMap(int initialCapacity, float loadFactor) {
+            super(initialCapacity, loadFactor);
+        }
+
+        public net.minecraft.server.Chunk getLastChunkByPos() {
+            return lastChunkByPosThread.get();
+        }
+
+        public Chunk setLastChunkByPos(net.minecraft.server.Chunk lastChunkByPos) {
+            lastChunkByPosThread.set(lastChunkByPos);
+            return lastChunkByPos;
+        }
+
+        @Override
+        public Chunk get(Object key) {
+            if (getLastChunkByPos() != null && key.equals(getLastChunkByPos().chunkKey)) {
+                return getLastChunkByPos();
+            }
+            return setLastChunkByPos(super.get(key));
+        }
+
+        @Override
+        public Chunk remove(Object key) {
+            if (getLastChunkByPos() != null && key.equals(getLastChunkByPos().chunkKey)) {
+                setLastChunkByPos(null);
+            }
+            return super.remove(key);
+        }
+
+    }
+    // Titanium end
+
     // Paper end
     public WorldServer world;
 
@@ -163,32 +207,40 @@ public class ChunkProviderServer implements IChunkProvider {
                 chunk = ChunkIOExecutor.syncChunkLoad(world, loader, this, i, j);
             }
         } else if (chunk == null) {
-            chunk = originalGetChunkAt(i, j);
+            chunk = originalGetChunkAt(i, j, runnable);
         }
 
         unloadQueue.remove(key); //IonSpigot // SportPaper
         // If we didn't load the chunk async and have a callback run it now
-        if (runnable != null) {
+        if (chunk != null && runnable != null) {
             runnable.run();
         }
 
         return chunk;
     }
+
     public Chunk originalGetChunkAt(int i, int j) {
+        return originalGetChunkAt(i, j, null);
+    }
+
+    public Chunk originalGetChunkAt(int i, int j, Runnable runnable) {
         long key = LongHash.toLong(i, j); // IonSpigot - Only create key once
         Chunk chunk = (Chunk) this.chunks.get(key);
-        boolean newChunk = false;
         // CraftBukkit end
 
         if (chunk == null) {
-            world.timings.syncChunkLoadTimer.startTiming(); // Spigot
             chunk = this.loadChunk(i, j);
             if (chunk == null) {
                 if (this.chunkProvider == null) {
                     chunk = this.emptyChunk;
                 } else {
                     try {
-                        chunk = this.chunkProvider.getOrCreateChunk(i, j);
+                        if (runnable != null) {
+                            ChunkGenExecutor.queueChunkGen(world, i, j, this.chunkProvider, this, runnable);
+                            return null;
+                        } else {
+                            chunk = ChunkGenExecutor.syncChunkGen(world, i, j, this.chunkProvider, this);
+                        }
                     } catch (Throwable throwable) {
                         CrashReport crashreport = CrashReport.a(throwable, "Exception generating new chunk");
                         CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Chunk to be generated");
@@ -199,44 +251,15 @@ public class ChunkProviderServer implements IChunkProvider {
                         throw new ReportedException(crashreport);
                     }
                 }
-                newChunk = true; // CraftBukkit
-            }
-
-            this.chunks.put(key, chunk); // IonSpigot
-            
-            chunk.addEntities();
-            
-            // CraftBukkit start
-            Server server = world.getServer();
-            if (server != null) {
-                /*
-                 * If it's a new world, the first few chunks are generated inside
-                 * the World constructor. We can't reliably alter that, so we have
-                 * no way of creating a CraftWorld/CraftServer at that point.
-                 */
-                server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, newChunk));
             }
+        }
 
-            // Update neighbor counts
-            for (int x = -2; x < 3; x++) {
-                for (int z = -2; z < 3; z++) {
-                    if (x == 0 && z == 0) {
-                        continue;
-                    }
+        this.unloadQueue.remove(key); // SportPaper
 
-                    Chunk neighbor = this.getChunkIfLoaded(chunk.locX + x, chunk.locZ + z);
-                    if (neighbor != null) {
-                        neighbor.setNeighborLoaded(-x, -z);
-                        chunk.setNeighborLoaded(x, z);
-                    }
-                }
-            }
-            // CraftBukkit end
-            chunk.loadNearby(this, this, i, j);
-            world.timings.syncChunkLoadTimer.stopTiming(); // Spigot
+        if (chunk != null && runnable != null) {
+            runnable.run();
         }
 
-        this.unloadQueue.remove(key); // IonSpigot // SportPaper
         return chunk;
     }
 
diff --git a/src/main/java/net/minecraft/server/IntCache.java b/src/main/java/net/minecraft/server/IntCache.java
index bfbbf9f8e..3da46ae67 100644
--- a/src/main/java/net/minecraft/server/IntCache.java
+++ b/src/main/java/net/minecraft/server/IntCache.java
@@ -6,6 +6,8 @@ import java.lang.ref.WeakReference;
 import java.util.Iterator;
 import java.util.List;
 // Migot end
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import net.titanium.config.TitaniumConfig;
 
 public class IntCache {
@@ -15,14 +17,12 @@ public class IntCache {
         @Override
         protected IntCache initialValue() {
             IntCache cache = new IntCache();
-            synchronized (ALL_CACHES) {
-                ALL_CACHES.add(new WeakReference<>(cache));
-            }
-            return new IntCache();
+            ALL_CACHES.add(new WeakReference<>(cache));
+            return cache;
         }
     };
 
-    private static final List<WeakReference<IntCache>> ALL_CACHES = new ObjectArrayList<>();
+    private static final Set<WeakReference<IntCache>> ALL_CACHES = ConcurrentHashMap.newKeySet(); // Titanium - ConcurrentSet
 
     private int a = 256;
     private final List<int[]> b = new ObjectArrayList<>();
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index f8416b988..100c3deee 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -39,6 +39,7 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
+import net.titanium.chunk.gen.ChunkGenExecutor;
 import net.titanium.config.TitaniumConfig;
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
@@ -898,6 +899,8 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         org.bukkit.craftbukkit.chunkio.ChunkIOExecutor.tick();
         SpigotTimings.chunkIOTickTimer.stopTiming(); // Spigot
 
+        ChunkGenExecutor.tick();
+
         SpigotTimings.timeUpdateTimer.startTiming(); // Spigot
         // Send time updates to everyone, it will get the right time from the world the player is in.
         // Paper start - optimize time updates
diff --git a/src/main/java/net/titanium/chunk/gen/ChunkGenExecutor.java b/src/main/java/net/titanium/chunk/gen/ChunkGenExecutor.java
new file mode 100644
index 000000000..8a5cb8700
--- /dev/null
+++ b/src/main/java/net/titanium/chunk/gen/ChunkGenExecutor.java
@@ -0,0 +1,29 @@
+package net.titanium.chunk.gen;
+
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkProviderServer;
+import net.minecraft.server.IChunkProvider;
+import net.minecraft.server.MCUtil;
+import net.minecraft.server.World;
+import net.titanium.executor.AsynchronousExecutor;
+
+public class ChunkGenExecutor {
+
+    static final int BASE_THREADS = 8;
+    static final int PLAYERS_PER_THREAD = 50;
+
+    private static final AsynchronousExecutor<QueuedChunk, Chunk, ChunkGenProvider> CHUNK_GEN_EXECUTOR = new AsynchronousExecutor<>(BASE_THREADS, new ChunkGenProvider());
+
+    public static void queueChunkGen(World world, int x, int z, IChunkProvider chunkGenerator, ChunkProviderServer provider, Runnable runnable) {
+        CHUNK_GEN_EXECUTOR.execute(new QueuedChunk(world, x, z, chunkGenerator, provider), runnable);
+    }
+
+    public static Chunk syncChunkGen(World world, int x, int z, IChunkProvider chunkGenerator, ChunkProviderServer provider) {
+        return MCUtil.ensureMain("Async Chunk Gen", () -> CHUNK_GEN_EXECUTOR.getSkipQueue(new QueuedChunk(world, x, z, chunkGenerator, provider))); // Paper
+    }
+
+    public static void tick() {
+        CHUNK_GEN_EXECUTOR.finishActive();
+    }
+
+}
diff --git a/src/main/java/net/titanium/chunk/gen/ChunkGenProvider.java b/src/main/java/net/titanium/chunk/gen/ChunkGenProvider.java
new file mode 100644
index 000000000..e9fed86b3
--- /dev/null
+++ b/src/main/java/net/titanium/chunk/gen/ChunkGenProvider.java
@@ -0,0 +1,59 @@
+package net.titanium.chunk.gen;
+
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.IChunkProvider;
+import net.titanium.executor.CallbacksProvider;
+import org.bukkit.Server;
+import org.bukkit.craftbukkit.util.LongHash;
+
+public class ChunkGenProvider implements CallbacksProvider<QueuedChunk, Chunk> {
+
+    @Override
+    public int hashCode(QueuedChunk queuedChunk) {
+        return queuedChunk.hashCode();
+    }
+
+    @Override
+    public Chunk asyncStage(QueuedChunk queuedChunk) {
+        IChunkProvider chunkGenerator = queuedChunk.chunkGenerator;
+        return chunkGenerator.getOrCreateChunk(queuedChunk.x, queuedChunk.z);
+    }
+
+    @Override
+    public void syncStage(QueuedChunk queuedChunk, Chunk chunk) {
+        if (chunk == null || queuedChunk.provider.chunks.containsKey(ChunkCoordIntPair.a(queuedChunk.x, queuedChunk.z))) {
+            queuedChunk.provider.originalGetChunkAt(queuedChunk.x, queuedChunk.z);
+            return;
+        }
+
+        chunk.world.timings.syncChunkLoadTimer.startTiming(); // Spigot
+
+        queuedChunk.provider.chunks.put(LongHash.toLong(queuedChunk.x, queuedChunk.z), chunk);
+        chunk.addEntities();
+
+        Server server = queuedChunk.provider.world.getServer();
+        if (server != null) {
+            server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, true));
+        }
+
+        // Update neighbor counts
+        for (int x = -2; x < 3; x++) {
+            for (int z = -2; z < 3; z++) {
+                if (x == 0 && z == 0) {
+                    continue;
+                }
+
+                Chunk neighbor = queuedChunk.provider.getChunkIfLoaded(chunk.locX + x, chunk.locZ + z);
+                if (neighbor != null) {
+                    neighbor.setNeighborLoaded(-x, -z);
+                    chunk.setNeighborLoaded(x, z);
+                }
+            }
+        }
+
+        chunk.loadNearby(queuedChunk.provider, queuedChunk.provider, queuedChunk.x, queuedChunk.z);
+        chunk.world.timings.syncChunkLoadTimer.stopTiming(); // Spigot
+    }
+
+}
diff --git a/src/main/java/net/titanium/chunk/gen/QueuedChunk.java b/src/main/java/net/titanium/chunk/gen/QueuedChunk.java
new file mode 100644
index 000000000..bd0e77c7c
--- /dev/null
+++ b/src/main/java/net/titanium/chunk/gen/QueuedChunk.java
@@ -0,0 +1,47 @@
+package net.titanium.chunk.gen;
+
+import net.minecraft.server.ChunkProviderServer;
+import net.minecraft.server.IChunkProvider;
+import net.minecraft.server.World;
+
+class QueuedChunk {
+
+    final World world;
+    final int x;
+    final int z;
+    final IChunkProvider chunkGenerator;
+    final ChunkProviderServer provider;
+
+    public QueuedChunk(int x, int z, IChunkProvider chunkGenerator, World world, ChunkProviderServer provider) {
+        this.x = x;
+        this.z = z;
+        this.chunkGenerator = chunkGenerator;
+        this.world = world;
+        this.provider = provider;
+    }
+
+    public QueuedChunk(World world, int x, int z, IChunkProvider chunkGenerator, ChunkProviderServer provider) {
+        this.world = world;
+        this.x = x;
+        this.z = z;
+        this.chunkGenerator = chunkGenerator;
+        this.provider = provider;
+    }
+
+
+    @Override
+    public int hashCode() {
+        return (x * 31 + z * 29) ^ world.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        if (object instanceof QueuedChunk) {
+            QueuedChunk other = (QueuedChunk) object;
+            return x == other.x && z == other.z && world == other.world;
+        }
+
+        return false;
+    }
+
+}
diff --git a/src/main/java/net/titanium/executor/AsynchronousExecutor.java b/src/main/java/net/titanium/executor/AsynchronousExecutor.java
new file mode 100644
index 000000000..434386af4
--- /dev/null
+++ b/src/main/java/net/titanium/executor/AsynchronousExecutor.java
@@ -0,0 +1,145 @@
+package net.titanium.executor;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Queue;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+public class AsynchronousExecutor<I, O, P extends CallbacksProvider<I, O>> {
+
+    private final ThreadPoolExecutor pool;
+    private final P provider;
+
+    private final Map<Integer, Task> runningTasks = new HashMap<>();
+    private final Queue<Task> finishedTasks = new ConcurrentLinkedQueue<>();
+
+    public AsynchronousExecutor(int coreSize, P provider) {
+        this.pool = new ThreadPoolExecutor(coreSize, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<>());
+        this.provider = provider;
+    }
+
+    public void execute(I input, Runnable callback) {
+        Task task = runningTasks.get(input.hashCode());
+        if (task == null) {
+            runningTasks.put(provider.hashCode(input), task = new Task(input));
+            pool.execute(task);
+        }
+        task.callbacks.add(callback);
+    }
+
+    private O skipQueue(I input) throws RuntimeException {
+        Task task = runningTasks.get(input.hashCode());
+        if (task != null) {
+            return task.get();
+        }
+        O object = provider.asyncStage(input);
+        provider.syncStage(input, object);
+        return object;
+    }
+
+    public O getSkipQueue(I input) throws RuntimeException {
+        return skipQueue(input);
+    }
+
+    public void finishActive() throws RuntimeException {
+        final Queue<Task> finished = this.finishedTasks;
+        while (!finished.isEmpty()) {
+            finishedTasks.poll().startSyncStage();
+        }
+    }
+
+    private class Task implements Runnable {
+
+        private final I input;
+
+        private O output;
+
+        private Stage ASYNC_STAGE = Stage.PENDING;
+        private Stage SYNC_STAGE = Stage.PENDING;
+
+        private final Set<Runnable> callbacks = ConcurrentHashMap.newKeySet();
+
+        private Task(I input) {
+            this.input = input;
+        }
+
+        @Override
+        public void run() {
+            if (this.startAsyncStage()) {
+                finishedTasks.add(this);
+            }
+        }
+
+        public boolean startAsyncStage() {
+            ASYNC_STAGE = Stage.STARTED;
+
+            try {
+                this.output = provider.asyncStage(input);
+
+            } finally {
+                synchronized (this) {
+                    ASYNC_STAGE = Stage.COMPLETED;
+                    this.notifyAll();
+                }
+
+            }
+
+            return true;
+        }
+
+        public void startSyncStage() {
+            synchronized (this) {
+                while (ASYNC_STAGE != Stage.COMPLETED) {
+                    try {
+                        this.wait();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                        throw new RuntimeException("Unable to handle interruption on " + Thread.currentThread());
+                    }
+                }
+
+                try {
+                    SYNC_STAGE = Stage.STARTED;
+
+                    provider.syncStage(this.input, this.output);
+                    for (Runnable callback : callbacks) {
+                        if (callback != null) {
+                            callback.run();
+                        }
+                    }
+                } finally {
+                    runningTasks.remove(input.hashCode());
+                    SYNC_STAGE = Stage.COMPLETED;
+                }
+            }
+        }
+
+        public O get() {
+            this.ASYNC_STAGE = Stage.STARTED;
+            this.output = provider.asyncStage(input);
+            this.ASYNC_STAGE = Stage.COMPLETED;
+
+            this.SYNC_STAGE = Stage.STARTED;
+            provider.syncStage(this.input, this.output);
+            for (Runnable callback : callbacks) {
+                callback.run();
+            }
+            this.SYNC_STAGE = Stage.COMPLETED;
+            return this.output;
+        }
+
+    }
+
+    private enum Stage {
+        PENDING,
+        STARTED,
+        COMPLETED;
+    }
+
+
+}
diff --git a/src/main/java/net/titanium/executor/CallbacksProvider.java b/src/main/java/net/titanium/executor/CallbacksProvider.java
new file mode 100644
index 000000000..39d468d8b
--- /dev/null
+++ b/src/main/java/net/titanium/executor/CallbacksProvider.java
@@ -0,0 +1,15 @@
+package net.titanium.executor;
+
+import net.minecraft.server.Chunk;
+
+public interface CallbacksProvider<I, O> {
+
+    default int hashCode(I input) {
+        return input.hashCode();
+    }
+
+    O asyncStage(I input);
+
+    void syncStage(I input, O output);
+
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java b/src/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java
index 193c3621c..70dd6f4af 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java
@@ -177,6 +177,7 @@ public final class AsynchronousExecutor<P, T, C, E extends Throwable> {
                         if (t != null) {
                             throw t;
                         }
+
                         if (callbacks.isEmpty()) {
                             return;
                         }
-- 
2.36.0.windows.1

